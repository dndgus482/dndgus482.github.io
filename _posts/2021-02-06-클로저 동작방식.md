---
layout: post
title: 클로저 동작방식
---

**자바스크립트에서의 클로저와 자바와의 비교**

**이 글은 모던자바스크립트 Deep dive책의 내용을 토대로 작성되었습니다.**

자바스크립트에는 클로저가 있다.

```javascript
(이 코드는 클로저의 원리와 같지만 일반적으로 부르는 클로저는 아니다.)

function foo() {
  var a = 1;
  function bar() {
    return a + 2;  // 내부함수에서 외부함수를 참조하고 있다.
  }
  
  return bar();
}

console.log(foo()); // 3 출력
```

직관적으로 보면 당연할 수도 있다. "당연히 블록 내부에 있으니 외부 변수를 참조 할 수 있는 것 아닌가?"



하지만 이런 코드는 좀 이상해 보일 수 있다.

```javascript
function foo() {
  var a = 1;
  var bar = function() {
    return a + 2;  // 내부함수에서 외부함수를 참조하고 있다.
  };
  
  return bar;
}

console.log(foo()()); // foo를 호출해 반환받은 bar함수 호출
```

이것도 3을 출력하지만 a라는 변수를 쓰고 있음에도 a를 참조 할 수 없다. 마치 private 접근자 같은 느낌이다.

---
## 그렇다면 클로저는 어떻게 생기는 것인가???

우선 함수형 프로그래밍 언어는 함수가 1급객체이기 때문에 함수안에 함수를 만들고 함수를 넘겨줄 수 있다. 또한 자바스크립트는 전체 코드를 완전히 컴파일 후 실행하는 것이 아니라 동적으로 코드를 분석한다. 따라서 현재 실행되고 있는 상태를 저장하는 객체가 필요하다.  현재 실행되고 있는 환경의 변수나 스코프, this가 어떤 걸 가리키는지 등의 정보를 스택형식으로 담아놓는 객체(?)를 `실행 컨텍스트`라 한다. 

실행컨텍스트는 스택 같이 코드를 실행할 때, 함수에 진입할 때 생성되고 끝나면 종료된다. 

실행컨텍스트는 변수나 스코프, this 를 가리키는 별도의 객체들을 만들어 참조한다.

1. 자바스크립트는 처음 코드를 실행할 때 전역에서, 함수에 진입할 때 코드를 실행하기 위해 코드를 미리 분석한다. 함수는 호출할 수 있도록 함수 객체를 만들어 저장하고 변수는 할당만 하고 undefined가 된다.(호이스팅이 일어나는 이유) 이러한 변수 함수를 담아두는 객체를 전역 객체(Global Object) / 활성 객체(Activation Object)라 한다. 즉 전역 객체는 처음 실행될 때 하나, 함수에 진입할 때 마다 계속 생성된다. 그리고 실행컨텍스트가 이 GO와 AO를 참조한다. 

2. 변수들을 빠르게 검색하기 위해 스코프 체인을 만든다. 스코프 체인은 접근할 수 있는 GO/ AO들을 차례로 참조하는 배열이다. 배열의 0번째는 방금 만든 AO를, 1번째는 그 바로 바깥의 AO를,,, 해서 마지막은 GO이다.(shadowing이 일어나는 이유)
3. this는 함수 호출 패턴에 따라 결정되는데 일반적으로는 this가 GO를 가리키고 함수가 객체 프로퍼티일때 등 몇몇 특정한 상황에만 다르게 동작한다. 



이렇게 만들어지고 만약 첫번째 코드처럼 외부함수와 내부함수가 있다면 내부함수의 실행컨텍스트, AO가 사라지고, 외부함수의 실행컨텍스트, AO가 사라진다.(가비지 컬렉터는 참조되지 않는 객체들을 삭제한다)

그런데 만약 내부에서 함수를 만들었는데 그 함수를 리턴한다면???

그렇게 되면 외부함수의 실행컨텍스트가 내부함수의 실행컨텍스트보다 먼저 종료가 된다.(내부함수는 리턴되어 참조가 있으므로 계속 살아있다). 하지만 내부함수는 스코프체인에서 외부함수의 AO를 참조하고 있다. 따라서 외부함수의 실행컨텍스트가 사라져도 외부함수의 AO는 살아있다.

따라서 스코프 체인을 통해 클로저의 AO를 참조할 수 있는 방법은 잘 모르겠지만.. 개발자도구에서 볼 수는 있다.

![](/images/클로저.png)

console.dir(함수이름)을 이용하면 [[scope]] 을 볼 수 있는데 이것이 스코프 체인이고 0, 1에 들어있는 객체들은 AO, VO이다.

---

## 자바와 같은 언어들은 어떻게 클로저를 만들어낼까??

자바도 익명 내부 함수 등을 통해 함수형 프로그래밍의 개념을 어느정도 지원한다. 하지만 실제로 함수는 1급객체가 아니다.

하지만 위 코드와 같은 경우를 지원하기 위해 컴파일러가 외부변수를 복사해서 내부에 추가해준다(이를 캡쳐링이라 하는 것 같다). 따라서 사실상 외부 변수를 쓰는 것이 아니다. 또한 final 변수만 람다로 만들 수 있다.(자바 8에서는 final을 안 넣어도 실행되지만 값을 바꾸지 않아야 한다)

final만 가능한 이유는 실제 변수가 아니라 복사된 변수기 때문에 외부 변수와 동기화가 되지 않는다.. 라고 하는 것 같다..


---

## 참조

<https://poiemaweb.com/js-execution-context> - 모던 자바스크립트 Deep Dive 책, 블로그

<https://meetup.toast.com/posts/86> - 토스트 기술 블로그

<https://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class> - 스택오버플로우